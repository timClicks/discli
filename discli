#! /usr/bin/env python3

import argparse
import datetime
import json
import os
import re
import time
import os.path
import glob
import requests
import sys
import textwrap
import yaml
from urllib.parse import urljoin


dotfile = ".discli"

def counter(start=0):
    i = start
    while True:
        yield i
        i = i + 1

def now():
    return datetime.datetime.utcnow().isoformat(sep='T', timespec='minutes') + '+00:00'

class DiscourseHelper:

    def __init__(self):
        self.http = requests.Session()
        parser = argparse.ArgumentParser(
            description='Helper to work with discourse files locally',
            usage=textwrap.dedent('''\
                discli <command> [<arg> ...]

                Commands:
                   init <url> <username> <api_key>   Record your API key and target Discourse
                   forget                            Deletes your credentials
                
                Commands that interact with Discourse directly:
                   get <topic-id>                    Download a Discourse topic 
                   copy <topic-id>                   Update a topic with the local file's contents
                   send <topic-id>                   Issue copy, then remove the local file
                   gulp <category>                   Get all the posts for category
                '''))
        parser.add_argument('command', help='Subcommand to run')
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print('Unrecognized command')
            parser.print_help()
            exit(1)
        # use dispatch pattern to invoke method with same name
        getattr(self, args.command)()

    @property
    def _identity_path(self):
        return os.path.expanduser("~/.local/share/discli")

    @property
    def _identity_file(self):
        return os.path.join(self._identity_path, 'identity')

    @property
    def identity(self):
        # TODO: cached property?
        with open(self._identity_file) as f:
            return yaml.load(f)

    @property
    def api_auth(self):
        identity = self.identity
        return {'api_key': identity['api-key'], 'api_username': identity['username']}

    @property
    def discourse_url(self):
        return self.identity['url']

    def init(self):
        parser = argparse.ArgumentParser(
            description='Record your api key and target discourse')
        parser.add_argument("url", help="discourse url")
        parser.add_argument("username", help="discourse username")
        parser.add_argument("api_key", help="discourse api key")
        args = parser.parse_args(sys.argv[2:])
        # TODO: optional file for identity to allow multiple discourses
        os.makedirs(self._identity_path, exist_ok=True)
        with open(self._identity_file, 'w') as f:
            yaml.dump({
                'api-key': args.api_key,
                'username': args.username,
                'url': args.url,
            }, f, default_flow_style=False)
        print("Values set: {}".format(self.identity))

    def forget(self):
        os.unlink(self._identity_file)

    def get(self):
        parser = argparse.ArgumentParser(
            description='get a single post')
        parser.add_argument("topic", help="topic id of the discourse post", type=int)
        args = parser.parse_args(sys.argv[2:])
        self.save_topic_as_file(args.topic)
    
    def save_topic_as_file(self, topic_id):
        post_id = self.get_topic_first_post(topic_id)
        data = self.get_post(post_id)
        print(data)
        slug = data['topic_slug']
        id = data['id']
        filename = f"{topic_id}-{slug}.md"
        metadata = {
            'id': id,
            'slug': slug,
            'filename': filename,
            'updated_at': data['updated_at'],
        }
        self.update_metadata(topic_id, metadata)

        print(f"Saving {filename}")
        with open(filename, "w") as f:
            content = data['raw']
            if content[-1] != '\n':
                content += '\n'
            f.write(content)

    def _update_topic(self, remove_local=True):
        parser = argparse.ArgumentParser(
            description='update a topic')
        parser.add_argument("topic", help="topic id or filename of the discourse post")
        args = parser.parse_args(sys.argv[2:])

        topic_id, local = self.get_topic_metadata(args.topic)
        data = self.get_post(local['id'])

        if data['updated_at'] != local['updated_at']:
            raise RuntimeError("topic was updated at {} within discourse, aborting".format(data['updated_at']))
        filename = local['filename']
        with open(filename) as f:
            content = f.read()
            self.put_post(local['id'], content)
        self.update_metadata(topic_id, None)
        if remove_local:
            os.remove(filename)

    def copy(self):
        self._update_topic(remove_local=False)

    def send(self):
        self._update_topic(remove_local=True)

    def get_post(self, id):
        response = self.request(f"posts/{id}.json")
        if response.status_code == 200:
            return json.loads(response.text)
        raise RuntimeError("couldn't get post {}: status code {}", id, response.status_code)

    def gulp(self):
        """
        Get all the posts in a category
        """

        parser = argparse.ArgumentParser(description='get all posts in category')
        parser.add_argument("category", help="name of the category to get posts from", type=str)
        args = parser.parse_args(sys.argv[2:])

        query_parts = [f"category:{args.category}"]
        last_time = self.last_gulp()
        if last_time:
            query_parts.append(f"updated-after:{last_time}")

        params = {
            'q': '%20'.join(query_parts)
        }

        for page in counter(start=1):
            print(f"Getting page {page} of results...")
            params['page'] = f"{page}"

            response = self.request("/search.json", params=params)

            if response.status_code != 200:
                raise RuntimeError("couldn't get category posts {}: status code {}", id, response.status_code)

            results = response.json()

            if 'topics' not in results:
                break

            topics = results['topics']

            for topic in topics:
                if glob.glob(f"{topic['id']}-*.md"):
                    print(f"File for topic {topic['id']} already exists. Skipping.")
                    continue

                self.save_topic_as_file(topic["id"])
        self.update_metadata('_meta', {'updated_at': now()})


    def request(self, path, data=None, params=None, method='GET'):
        """
        Use requests to fetch an API URL,
        padding in the auth token,
        and retrying if we get a 429 response
        """
        assert method in {"GET", "PUT", "POST"}

        if params is None:
            params = {}

        for k,v in self.api_auth.items():
            params[k] = v

        response = self.http.request(method, urljoin(self.identity["url"], path), params=params, data=data)
        if response.status_code != 429:
            return response

        error_message = response.json()["errors"][0]
        seconds_match = re.search("wait (\d+) seconds", error_message)
        if seconds_match:
            seconds = int(seconds_match.group(1)) + 1
        else:
            seconds = 5

        print(
            f"  > 429 from API, waiting {seconds} seconds ... "
            f"('{response.json()['errors']}')"
        )
        time.sleep(seconds)
        return self.request(path)

    def put_post(self, id, content):
        post_path = urljoin(self.identity["url"], f"posts/{id}.json")

        data = self.api_auth
        data["post[raw]"] = content
        resp = self.request(post_path, method="PUT", data=data)
        if resp.status_code != 200:
            raise RuntimeError("couldn't update post {}: status code {}", id, r.status_code)

    def get_topic_first_post(self, id):
        r = self.request(f"t/{id}.json")
        if r.status_code == 200:
            topic = json.loads(r.text)
            first_post = topic['post_stream']['posts'][0]
            return first_post['id']
        raise RuntimeError("couldn't get topic {}: status code {}", id, r.status_code)

    def update_metadata(self, post, data):
        info = self.dotfile_contents()
        if data is None:
            del info[post]
        else:
            info[post] = data
        with open(dotfile, "w") as f:
            yaml.dump(info, f, default_flow_style=False)

    def dotfile_contents(self):
        if not os.path.exists(dotfile):
            return {}
        with open(dotfile) as f:
            return yaml.load(f)

    def read_metadata(self, post):
        info = self.dotfile_contents()
        if post in info:
            return info[post]
        return {}

    def get_topic_metadata(self, topic):
        # topic is either the topic number or the name of the file.
        info = self.dotfile_contents()
        try:
            topic_id = int(topic)
            return topic_id, info[topic_id] 
        except:
            for id, meta in info.items():
                if meta['filename'] == topic:
                    return id, meta

        raise RuntimeError(f"{topic} is neither a topic id nor a known filename")

    def last_gulp(self):
        info = self.dotfile_contents()
        return info.get('_meta', {}).get("updated_at")


if __name__ == '__main__':
    DiscourseHelper()
